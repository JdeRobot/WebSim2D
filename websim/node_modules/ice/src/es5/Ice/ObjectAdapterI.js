var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// **********************************************************************
//
// Copyright (c) 2003-2018 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************

var Ice = require("../Ice/ModuleRegistry").Ice;
Ice._ModuleRegistry.require(module, ["../Ice/AsyncResultBase", "../Ice/Debug", "../Ice/Identity", "../Ice/LocalException", "../Ice/PropertyNames", "../Ice/Router", "../Ice/ServantManager", "../Ice/StringUtil", "../Ice/UUID", "../Ice/ArrayUtil", "../Ice/Promise", "../Ice/Timer"]);

var AsyncResultBase = Ice.AsyncResultBase;
var Debug = Ice.Debug;
var Identity = Ice.Identity;
var PropertyNames = Ice.PropertyNames;
var ServantManager = Ice.ServantManager;
var StringUtil = Ice.StringUtil;
var ArrayUtil = Ice.ArrayUtil;
var Timer = Ice.Timer;

var _suffixes = ["ACM", "AdapterId", "Endpoints", "Locator", "Locator.EncodingVersion", "Locator.EndpointSelection", "Locator.ConnectionCached", "Locator.PreferSecure", "Locator.CollocationOptimized", "Locator.Router", "MessageSizeMax", "PublishedEndpoints", "ReplicaGroupId", "Router", "Router.EncodingVersion", "Router.EndpointSelection", "Router.ConnectionCached", "Router.PreferSecure", "Router.CollocationOptimized", "Router.Locator", "Router.Locator.EndpointSelection", "Router.Locator.ConnectionCached", "Router.Locator.PreferSecure", "Router.Locator.CollocationOptimized", "Router.Locator.LocatorCacheTimeout", "Router.Locator.InvocationTimeout", "Router.LocatorCacheTimeout", "Router.InvocationTimeout", "ProxyOptions", "ThreadPool.Size", "ThreadPool.SizeMax", "ThreadPool.SizeWarn", "ThreadPool.StackSize", "ThreadPool.Serialize"];

var StateUninitialized = 0; // Just constructed.
var StateHeld = 1;
//const StateWaitActivate = 2;
var StateActive = 3;
//const StateDeactivating = 4;
var StateDeactivated = 5;
var StateDestroyed = 6;

//
// Only for use by IceInternal.ObjectAdapterFactory
//

var ObjectAdapterI = function () {
    function ObjectAdapterI(instance, communicator, objectAdapterFactory, name, router, noConfig, promise) {
        var _this = this;

        _classCallCheck(this, ObjectAdapterI);

        this._instance = instance;
        this._communicator = communicator;
        this._objectAdapterFactory = objectAdapterFactory;
        this._servantManager = new ServantManager(instance, name);
        this._name = name;
        this._publishedEndpoints = [];
        this._routerInfo = null;
        this._state = StateUninitialized;
        this._noConfig = noConfig;
        this._statePromises = [];

        if (this._noConfig) {
            this._reference = this._instance.referenceFactory().createFromString("dummy -t", "");
            this._messageSizeMax = this._instance.messageSizeMax();
            promise.resolve(this);
            return;
        }

        var properties = this._instance.initializationData().properties;
        var unknownProps = [];
        var noProps = this.filterProperties(unknownProps);

        //
        // Warn about unknown object adapter properties.
        //
        if (unknownProps.length !== 0 && properties.getPropertyAsIntWithDefault("Ice.Warn.UnknownProperties", 1) > 0) {
            var message = ["found unknown properties for object adapter `" + name + "':"];
            unknownProps.forEach(function (unknownProp) {
                return message.push("\n    " + unknownProp);
            });
            this._instance.initializationData().logger.warning(message.join(""));
        }

        //
        // Make sure named adapter has some configuration.
        //
        if (router === null && noProps) {
            throw new Ice.InitializationException("object adapter `" + this._name + "' requires configuration");
        }

        //
        // Setup a reference to be used to get the default proxy options
        // when creating new proxies. By default, create twoway proxies.
        //
        var proxyOptions = properties.getPropertyWithDefault(this._name + ".ProxyOptions", "-t");
        try {
            this._reference = this._instance.referenceFactory().createFromString("dummy " + proxyOptions, "");
        } catch (e) {
            if (e instanceof Ice.ProxyParseException) {
                throw new Ice.InitializationException("invalid proxy options `" + proxyOptions + "' for object adapter `" + name + "'");
            } else {
                throw e;
            }
        }

        {
            var defaultMessageSizeMax = this._instance.messageSizeMax() / 1024;
            var num = properties.getPropertyAsIntWithDefault(this._name + ".MessageSizeMax", defaultMessageSizeMax);
            if (num < 1 || num > 0x7fffffff / 1024) {
                this._messageSizeMax = 0x7fffffff;
            } else {
                this._messageSizeMax = num * 1024; // Property is in kilobytes, _messageSizeMax in bytes
            }
        }

        try {
            if (router === null) {
                router = Ice.RouterPrx.uncheckedCast(this._instance.proxyFactory().propertyToProxy(this._name + ".Router"));
            }
            var p = void 0;
            if (router !== null) {
                this._routerInfo = this._instance.routerManager().find(router);
                Debug.assert(this._routerInfo !== null);

                //
                // Make sure this router is not already registered with another adapter.
                //
                if (this._routerInfo.getAdapter() !== null) {
                    throw new Ice.AlreadyRegisteredException("object adapter with router", Ice.identityToString(router.ice_getIdentity(), this._instance.toStringMode()));
                }

                //
                // Associate this object adapter with the router. This way,
                // new outgoing connections to the router's client proxy will
                // use this object adapter for callbacks.
                //
                this._routerInfo.setAdapter(this);

                //
                // Also modify all existing outgoing connections to the
                // router's client proxy to use this object adapter for
                // callbacks.
                //
                p = this._instance.outgoingConnectionFactory().setRouterInfo(this._routerInfo);
            } else {
                var endpoints = properties.getProperty(this._name + ".Endpoints");
                if (endpoints.length > 0) {
                    throw new Ice.FeatureNotSupportedException("object adapter endpoints not supported");
                }
                p = Ice.Promise.resolve();
            }

            p.then(function () {
                return _this.computePublishedEndpoints();
            }).then(function (endpoints) {
                _this._publishedEndpoints = endpoints;
                promise.resolve(_this);
            }, function (ex) {
                _this.destroy();
                promise.reject(ex);
            });
        } catch (ex) {
            this.destroy();
            throw ex;
        }
    }

    _createClass(ObjectAdapterI, [{
        key: "getName",
        value: function getName() {
            //
            // No mutex lock necessary, _name is immutable.
            //
            return this._noConfig ? "" : this._name;
        }
    }, {
        key: "getCommunicator",
        value: function getCommunicator() {
            return this._communicator;
        }
    }, {
        key: "activate",
        value: function activate() {
            var promise = new AsyncResultBase(this._communicator, "activate", null, null, this);
            this.setState(StateActive);
            promise.resolve();
            return promise;
        }
    }, {
        key: "hold",
        value: function hold() {
            this.checkForDeactivation();
            this.setState(StateHeld);
        }
    }, {
        key: "waitForHold",
        value: function waitForHold() {
            var promise = new AsyncResultBase(this._communicator, "waitForHold", null, null, this);
            try {
                this.checkForDeactivation();
                this.waitState(StateHeld, promise);
            } catch (ex) {
                promise.reject(ex);
            }
            return promise;
        }
    }, {
        key: "deactivate",
        value: function deactivate() {
            var promise = new AsyncResultBase(this._communicator, "deactivate", null, null, this);
            if (this._state < StateDeactivated) {
                this.setState(StateDeactivated);
                this._instance.outgoingConnectionFactory().removeAdapter(this);
            }
            promise.resolve();
            return promise;
        }
    }, {
        key: "waitForDeactivate",
        value: function waitForDeactivate() {
            var promise = new AsyncResultBase(this._communicator, "waitForDeactivate", null, null, this);
            this.waitState(StateDeactivated, promise);
            return promise;
        }
    }, {
        key: "isDeactivated",
        value: function isDeactivated() {
            return this._state >= StateDeactivated;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            var _this2 = this;

            // NOTE: we don't call waitForDeactivate since it's currently a no-op.
            return this.deactivate().then(function () {
                if (_this2._state < StateDestroyed) {
                    _this2.setState(StateDestroyed);
                    _this2._servantManager.destroy();
                    _this2._objectAdapterFactory.removeObjectAdapter(_this2);
                    _this2._publishedEndpoints = [];
                }
                var promise = new AsyncResultBase(_this2._communicator, "destroy", null, null, _this2);
                promise.resolve();
                return promise;
            });
        }
    }, {
        key: "add",
        value: function add(object, ident) {
            return this.addFacet(object, ident, "");
        }
    }, {
        key: "addFacet",
        value: function addFacet(object, ident, facet) {
            this.checkForDeactivation();
            this.checkIdentity(ident);
            this.checkServant(object);

            //
            // Create a copy of the Identity argument, in case the caller
            // reuses it.
            //
            var id = ident.clone();

            this._servantManager.addServant(object, id, facet);

            return this.newProxy(id, facet);
        }
    }, {
        key: "addWithUUID",
        value: function addWithUUID(object) {
            return this.addFacetWithUUID(object, "");
        }
    }, {
        key: "addFacetWithUUID",
        value: function addFacetWithUUID(object, facet) {
            return this.addFacet(object, new Identity(Ice.generateUUID(), ""), facet);
        }
    }, {
        key: "addDefaultServant",
        value: function addDefaultServant(servant, category) {
            this.checkServant(servant);
            this.checkForDeactivation();

            this._servantManager.addDefaultServant(servant, category);
        }
    }, {
        key: "remove",
        value: function remove(ident) {
            return this.removeFacet(ident, "");
        }
    }, {
        key: "removeFacet",
        value: function removeFacet(ident, facet) {
            this.checkForDeactivation();
            this.checkIdentity(ident);

            return this._servantManager.removeServant(ident, facet);
        }
    }, {
        key: "removeAllFacets",
        value: function removeAllFacets(ident) {
            this.checkForDeactivation();
            this.checkIdentity(ident);

            return this._servantManager.removeAllFacets(ident);
        }
    }, {
        key: "removeDefaultServant",
        value: function removeDefaultServant(category) {
            this.checkForDeactivation();

            return this._servantManager.removeDefaultServant(category);
        }
    }, {
        key: "find",
        value: function find(ident) {
            return this.findFacet(ident, "");
        }
    }, {
        key: "findFacet",
        value: function findFacet(ident, facet) {
            this.checkForDeactivation();
            this.checkIdentity(ident);
            return this._servantManager.findServant(ident, facet);
        }
    }, {
        key: "findAllFacets",
        value: function findAllFacets(ident) {
            this.checkForDeactivation();
            this.checkIdentity(ident);
            return this._servantManager.findAllFacets(ident);
        }
    }, {
        key: "findByProxy",
        value: function findByProxy(proxy) {
            this.checkForDeactivation();
            var ref = proxy._getReference();
            return this.findFacet(ref.getIdentity(), ref.getFacet());
        }
    }, {
        key: "findDefaultServant",
        value: function findDefaultServant(category) {
            this.checkForDeactivation();
            return this._servantManager.findDefaultServant(category);
        }
    }, {
        key: "addServantLocator",
        value: function addServantLocator(locator, prefix) {
            this.checkForDeactivation();
            this._servantManager.addServantLocator(locator, prefix);
        }
    }, {
        key: "removeServantLocator",
        value: function removeServantLocator(prefix) {
            this.checkForDeactivation();
            return this._servantManager.removeServantLocator(prefix);
        }
    }, {
        key: "findServantLocator",
        value: function findServantLocator(prefix) {
            this.checkForDeactivation();
            return this._servantManager.findServantLocator(prefix);
        }
    }, {
        key: "createProxy",
        value: function createProxy(ident) {
            this.checkForDeactivation();
            this.checkIdentity(ident);
            return this.newProxy(ident, "");
        }
    }, {
        key: "createDirectProxy",
        value: function createDirectProxy(ident) {
            return this.createProxy(ident);
        }
    }, {
        key: "createIndirectProxy",
        value: function createIndirectProxy(ident) {
            throw new Ice.FeatureNotSupportedException("createIndirectProxy not supported");
        }
    }, {
        key: "setLocator",
        value: function setLocator(locator) {
            throw new Ice.FeatureNotSupportedException("setLocator not supported");
        }
    }, {
        key: "getEndpoints",
        value: function getEndpoints() {
            return [];
        }
    }, {
        key: "refreshPublishedEndpoints",
        value: function refreshPublishedEndpoints() {
            var _this3 = this;

            this.checkForDeactivation();
            return this.computePublishedEndpoints().then(function (endpoints) {
                return _this3._publishedEndpoints = endpoints;
            });
        }
    }, {
        key: "getPublishedEndpoints",
        value: function getPublishedEndpoints() {
            return ArrayUtil.clone(this._publishedEndpoints);
        }
    }, {
        key: "setPublishedEndpoints",
        value: function setPublishedEndpoints(newEndpoints) {
            this.checkForDeactivation();
            if (this._routerInfo !== null) {
                throw new Error("can't set published endpoints on object adapter associated with a router");
            }
            this._publishedEndpoints = ArrayUtil.clone(newEndpoints);
        }
    }, {
        key: "getServantManager",
        value: function getServantManager() {
            //
            // _servantManager is immutable.
            //
            return this._servantManager;
        }
    }, {
        key: "setAdapterOnConnection",
        value: function setAdapterOnConnection(connection) {
            this.checkForDeactivation();
            connection.setAdapterAndServantManager(this, _servantManager);
        }
    }, {
        key: "messageSizeMax",
        value: function messageSizeMax() {
            return this._messageSizeMax;
        }
    }, {
        key: "newProxy",
        value: function newProxy(ident, facet) {
            //
            // Now we also add the endpoints of the router's server proxy, if
            // any. This way, object references created by this object adapter
            // will also point to the router's server proxy endpoints.
            //
            //
            // Create a reference and return a proxy for this reference.
            //
            return this._instance.proxyFactory().referenceToProxy(this._instance.referenceFactory().create(ident, facet, this._reference, this._publishedEndpoints));
        }
    }, {
        key: "checkForDeactivation",
        value: function checkForDeactivation() {
            if (this._state >= StateDeactivated) {
                var ex = new Ice.ObjectAdapterDeactivatedException();
                ex.name = this.getName();
                throw ex;
            }
        }
    }, {
        key: "checkIdentity",
        value: function checkIdentity(ident) {
            if (ident.name === undefined || ident.name === null || ident.name.length === 0) {
                throw new Ice.IllegalIdentityException(ident);
            }

            if (ident.category === undefined || ident.category === null) {
                ident.category = "";
            }
        }
    }, {
        key: "checkServant",
        value: function checkServant(servant) {
            if (servant === undefined || servant === null) {
                throw new Ice.IllegalServantException("cannot add null servant to Object Adapter");
            }
        }
    }, {
        key: "computePublishedEndpoints",
        value: function computePublishedEndpoints() {
            var _this4 = this;

            var p = void 0;
            if (this._routerInfo !== null) {
                p = this._routerInfo.getServerEndpoints().then(function (endpts) {
                    //
                    // Remove duplicate endpoints, so we have a list of unique endpoints.
                    //
                    var endpoints = [];
                    endpts.forEach(function (endpoint) {
                        if (endpoints.findIndex(function (value) {
                            return endpoint.equals(value);
                        }) === -1) {
                            endpoints.push(endpoint);
                        }
                    });
                    return endpoints;
                });
            } else {

                //
                // Parse published endpoints. If set, these are used in proxies
                // instead of the connection factory Endpoints.
                //
                var endpoints = [];
                var s = this._instance.initializationData().properties.getProperty(this._name + ".PublishedEndpoints");
                var delim = " \t\n\r";

                var end = 0;
                var beg = void 0;
                while (end < s.length) {
                    beg = StringUtil.findFirstNotOf(s, delim, end);
                    if (beg === -1) {
                        if (s != "") {
                            throw new Ice.EndpointParseException("invalid empty object adapter endpoint");
                        }
                        break;
                    }

                    end = beg;
                    while (true) {
                        end = s.indexOf(':', end);
                        if (end == -1) {
                            end = s.length;
                            break;
                        } else {
                            var quoted = false;
                            var quote = beg;
                            while (true) {
                                quote = s.indexOf("\"", quote);
                                if (quote == -1 || end < quote) {
                                    break;
                                } else {
                                    quote = s.indexOf('\"', ++quote);
                                    if (quote == -1) {
                                        break;
                                    } else if (end < quote) {
                                        quoted = true;
                                        break;
                                    }
                                    ++quote;
                                }
                            }
                            if (!quoted) {
                                break;
                            }
                            ++end;
                        }
                    }

                    var es = s.substring(beg, end);
                    var endp = this._instance.endpointFactoryManager().create(es, false);
                    if (endp == null) {
                        throw new Ice.EndpointParseException("invalid object adapter endpoint `" + s + "'");
                    }
                    endpoints.push(endp);
                }

                p = Ice.Promise.resolve(endpoints);
            }

            return p.then(function (endpoints) {
                if (_this4._instance.traceLevels().network >= 1 && endpoints.length > 0) {
                    var _s = [];
                    _s.push("published endpoints for object adapter `");
                    _s.push(_this4._name);
                    _s.push("':\n");
                    var first = true;
                    endpoints.forEach(function (endpoint) {
                        if (!first) {
                            _s.push(":");
                        }
                        _s.push(endpoint.toString());
                        first = false;
                    });
                    _this4._instance.initializationData().logger.trace(_this4._instance.traceLevels().networkCat, _s.toString());
                }
                return endpoints;
            });
        }
    }, {
        key: "filterProperties",
        value: function filterProperties(unknownProps) {
            //
            // Do not create unknown properties list if Ice prefix, i.e., Ice, Glacier2, etc.
            //
            var addUnknown = true;
            var prefix = this._name + ".";
            for (var i = 0; i < PropertyNames.clPropNames.length; ++i) {
                if (prefix.indexOf(PropertyNames.clPropNames[i] + ".") === 0) {
                    addUnknown = false;
                    break;
                }
            }

            var noProps = true;
            var props = this._instance.initializationData().properties.getPropertiesForPrefix(prefix);
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = props[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var _step$value = _slicedToArray(_step.value, 2),
                        key = _step$value[0],
                        value = _step$value[1];

                    var valid = false;
                    for (var _i = 0; _i < _suffixes.length; ++_i) {
                        if (key === prefix + _suffixes[_i]) {
                            noProps = false;
                            valid = true;
                            break;
                        }
                    }

                    if (!valid && addUnknown) {
                        unknownProps.push(key);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return noProps;
        }
    }, {
        key: "setState",
        value: function setState(state) {
            var _this5 = this;

            if (this._state === state) {
                return;
            }
            this._state = state;

            var promises = [];
            (state < StateDeactivated ? [state] : [StateHeld, StateDeactivated]).forEach(function (s) {
                if (_this5._statePromises[s]) {
                    promises = promises.concat(_this5._statePromises[s]);
                    delete _this5._statePromises[s];
                }
            });
            if (promises.length > 0) {
                Timer.setImmediate(function () {
                    return promises.forEach(function (p) {
                        return p.resolve();
                    });
                });
            }
        }
    }, {
        key: "waitState",
        value: function waitState(state, promise) {
            if (this._state < StateDeactivated && (state === StateHeld && this._state !== StateHeld || state === StateDeactivated)) {
                if (this._statePromises[state]) {
                    this._statePromises[state].push(promise);
                } else {
                    this._statePromises[state] = [promise];
                }
            } else {
                promise.resolve();
            }
        }
    }]);

    return ObjectAdapterI;
}();

Ice.ObjectAdapterI = ObjectAdapterI;
module.exports.Ice = Ice;