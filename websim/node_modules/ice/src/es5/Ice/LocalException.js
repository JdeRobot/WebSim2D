var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// **********************************************************************
//
// Copyright (c) 2003-2018 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.7.1
//
// <auto-generated>
//
// Generated from file `LocalException.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

/* eslint-disable */
/* jshint ignore: start */

/* slice2js browser-bundle-skip */
(function (module, require, exports) {
    /* slice2js browser-bundle-skip-end */
    /* slice2js browser-bundle-skip */
    var _ModuleRegistry = require("../Ice/ModuleRegistry").Ice._ModuleRegistry;
    var Ice = _ModuleRegistry.require(module, ["../Ice/Exception", "../Ice/Long", "../Ice/HashMap", "../Ice/HashUtil", "../Ice/ArrayUtil", "../Ice/StreamHelpers", "../Ice/Identity", "../Ice/Version", "../Ice/BuiltinSequences"]).Ice;

    var Slice = Ice.Slice;
    /* slice2js browser-bundle-skip-end */

    /**
     * This exception is raised when a failure occurs during initialization.
     *
     **/
    Ice.InitializationException = function (_Ice$LocalException) {
        _inherits(_class, _Ice$LocalException);

        function _class() {
            var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class);

            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, _cause));

            _this.reason = reason;
            return _this;
        }

        _createClass(_class, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::InitializationException";
            }
        }]);

        return _class;
    }(Ice.LocalException);

    /**
     * This exception indicates that a failure occurred while initializing
     * a plug-in.
     *
     **/
    Ice.PluginInitializationException = function (_Ice$LocalException2) {
        _inherits(_class2, _Ice$LocalException2);

        function _class2() {
            var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class2);

            var _this2 = _possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this, _cause));

            _this2.reason = reason;
            return _this2;
        }

        _createClass(_class2, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::PluginInitializationException";
            }
        }]);

        return _class2;
    }(Ice.LocalException);

    /**
     * This exception is raised if a feature is requested that is not
     * supported with collocation optimization.
     *
     * @deprecated This exception is no longer used by the Ice run time
     **/
    Ice.CollocationOptimizationException = function (_Ice$LocalException3) {
        _inherits(_class3, _Ice$LocalException3);

        function _class3() {
            var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            _classCallCheck(this, _class3);

            return _possibleConstructorReturn(this, (_class3.__proto__ || Object.getPrototypeOf(_class3)).call(this, _cause));
        }

        _createClass(_class3, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::CollocationOptimizationException";
            }
        }]);

        return _class3;
    }(Ice.LocalException);

    /**
     * An attempt was made to register something more than once with
     * the Ice run time.
     *
     * This exception is raised if an attempt is made to register a
     * servant, servant locator, facet, value factory, plug-in, object
     * adapter, object, or user exception factory more than once for the
     * same ID.
     *
     **/
    Ice.AlreadyRegisteredException = function (_Ice$LocalException4) {
        _inherits(_class4, _Ice$LocalException4);

        function _class4() {
            var kindOfObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            var _cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

            _classCallCheck(this, _class4);

            var _this4 = _possibleConstructorReturn(this, (_class4.__proto__ || Object.getPrototypeOf(_class4)).call(this, _cause));

            _this4.kindOfObject = kindOfObject;
            _this4.id = id;
            return _this4;
        }

        _createClass(_class4, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::AlreadyRegisteredException";
            }
        }]);

        return _class4;
    }(Ice.LocalException);

    /**
     * An attempt was made to find or deregister something that is not
     * registered with the Ice run time or Ice locator.
     *
     * This exception is raised if an attempt is made to remove a servant,
     * servant locator, facet, value factory, plug-in, object adapter,
     * object, or user exception factory that is not currently registered.
     *
     * It's also raised if the Ice locator can't find an object or object
     * adapter when resolving an indirect proxy or when an object adapter
     * is activated.
     *
     **/
    Ice.NotRegisteredException = function (_Ice$LocalException5) {
        _inherits(_class5, _Ice$LocalException5);

        function _class5() {
            var kindOfObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            var _cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

            _classCallCheck(this, _class5);

            var _this5 = _possibleConstructorReturn(this, (_class5.__proto__ || Object.getPrototypeOf(_class5)).call(this, _cause));

            _this5.kindOfObject = kindOfObject;
            _this5.id = id;
            return _this5;
        }

        _createClass(_class5, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::NotRegisteredException";
            }
        }]);

        return _class5;
    }(Ice.LocalException);

    /**
     * The operation can only be invoked with a twoway request.
     *
     * This exception is raised if an attempt is made to invoke an
     * operation with <tt>ice_oneway</tt>, <tt>ice_batchOneway</tt>, <tt>ice_datagram</tt>,
     * or <tt>ice_batchDatagram</tt> and the operation has a return value,
     * out-parameters, or an exception specification.
     *
     **/
    Ice.TwowayOnlyException = function (_Ice$LocalException6) {
        _inherits(_class6, _Ice$LocalException6);

        function _class6() {
            var operation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class6);

            var _this6 = _possibleConstructorReturn(this, (_class6.__proto__ || Object.getPrototypeOf(_class6)).call(this, _cause));

            _this6.operation = operation;
            return _this6;
        }

        _createClass(_class6, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::TwowayOnlyException";
            }
        }]);

        return _class6;
    }(Ice.LocalException);

    /**
     * An attempt was made to clone a class that does not support
     * cloning.
     *
     * This exception is raised if <tt>ice_clone</tt> is called on
     * a class that is derived from an abstract Slice class (that is,
     * a class containing operations), and the derived class does not
     * provide an implementation of the <tt>ice_clone</tt> operation (C++ only).
     *
     **/
    Ice.CloneNotImplementedException = function (_Ice$LocalException7) {
        _inherits(_class7, _Ice$LocalException7);

        function _class7() {
            var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            _classCallCheck(this, _class7);

            return _possibleConstructorReturn(this, (_class7.__proto__ || Object.getPrototypeOf(_class7)).call(this, _cause));
        }

        _createClass(_class7, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::CloneNotImplementedException";
            }
        }]);

        return _class7;
    }(Ice.LocalException);

    /**
     * This exception is raised if an operation call on a server raises an
     * unknown exception. For example, for C++, this exception is raised
     * if the server throws a C++ exception that is not directly or
     * indirectly derived from <tt>Ice::LocalException</tt> or
     * <tt>Ice::UserException</tt>.
     *
     **/
    Ice.UnknownException = function (_Ice$LocalException8) {
        _inherits(_class8, _Ice$LocalException8);

        function _class8() {
            var unknown = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class8);

            var _this8 = _possibleConstructorReturn(this, (_class8.__proto__ || Object.getPrototypeOf(_class8)).call(this, _cause));

            _this8.unknown = unknown;
            return _this8;
        }

        _createClass(_class8, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::UnknownException";
            }
        }]);

        return _class8;
    }(Ice.LocalException);

    /**
     * This exception is raised if an operation call on a server raises a
     * local exception. Because local exceptions are not transmitted by
     * the Ice protocol, the client receives all local exceptions raised
     * by the server as {@link UnknownLocalException}. The only exception to this
     * rule are all exceptions derived from {@link RequestFailedException},
     * which are transmitted by the Ice protocol even though they are
     * declared <tt>local</tt>.
     *
     **/
    Ice.UnknownLocalException = function (_Ice$UnknownException) {
        _inherits(_class9, _Ice$UnknownException);

        function _class9(unknown) {
            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class9);

            return _possibleConstructorReturn(this, (_class9.__proto__ || Object.getPrototypeOf(_class9)).call(this, unknown, _cause));
        }

        _createClass(_class9, null, [{
            key: "_parent",
            get: function get() {
                return Ice.UnknownException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::UnknownLocalException";
            }
        }]);

        return _class9;
    }(Ice.UnknownException);

    /**
     * An operation raised an incorrect user exception.
     *
     * This exception is raised if an operation raises a
     * user exception that is not declared in the exception's
     * <tt>throws</tt> clause. Such undeclared exceptions are
     * not transmitted from the server to the client by the Ice
     * protocol, but instead the client just gets an
     * {@link UnknownUserException}. This is necessary in order to not violate
     * the contract established by an operation's signature: Only local
     * exceptions and user exceptions declared in the
     * <tt>throws</tt> clause can be raised.
     *
     **/
    Ice.UnknownUserException = function (_Ice$UnknownException2) {
        _inherits(_class10, _Ice$UnknownException2);

        function _class10(unknown) {
            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class10);

            return _possibleConstructorReturn(this, (_class10.__proto__ || Object.getPrototypeOf(_class10)).call(this, unknown, _cause));
        }

        _createClass(_class10, null, [{
            key: "_parent",
            get: function get() {
                return Ice.UnknownException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::UnknownUserException";
            }
        }]);

        return _class10;
    }(Ice.UnknownException);

    /**
     * This exception is raised if the Ice library version does not match
     * the version in the Ice header files.
     *
     **/
    Ice.VersionMismatchException = function (_Ice$LocalException9) {
        _inherits(_class11, _Ice$LocalException9);

        function _class11() {
            var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            _classCallCheck(this, _class11);

            return _possibleConstructorReturn(this, (_class11.__proto__ || Object.getPrototypeOf(_class11)).call(this, _cause));
        }

        _createClass(_class11, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::VersionMismatchException";
            }
        }]);

        return _class11;
    }(Ice.LocalException);

    /**
     * This exception is raised if the {@link Communicator} has been destroyed.
     *
     * @see Communicator#destroy
     *
     **/
    Ice.CommunicatorDestroyedException = function (_Ice$LocalException10) {
        _inherits(_class12, _Ice$LocalException10);

        function _class12() {
            var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            _classCallCheck(this, _class12);

            return _possibleConstructorReturn(this, (_class12.__proto__ || Object.getPrototypeOf(_class12)).call(this, _cause));
        }

        _createClass(_class12, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::CommunicatorDestroyedException";
            }
        }]);

        return _class12;
    }(Ice.LocalException);

    /**
     * This exception is raised if an attempt is made to use a deactivated
     * {@link ObjectAdapter}.
     *
     * @see ObjectAdapter#deactivate
     * @see Communicator#shutdown
     *
     **/
    Ice.ObjectAdapterDeactivatedException = function (_Ice$LocalException11) {
        _inherits(_class13, _Ice$LocalException11);

        function _class13() {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class13);

            var _this13 = _possibleConstructorReturn(this, (_class13.__proto__ || Object.getPrototypeOf(_class13)).call(this, _cause));

            _this13.name = name;
            return _this13;
        }

        _createClass(_class13, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::ObjectAdapterDeactivatedException";
            }
        }]);

        return _class13;
    }(Ice.LocalException);

    /**
     * This exception is raised if an {@link ObjectAdapter} cannot be activated.
     *
     * This happens if the {@link Locator} detects another active {@link ObjectAdapter} with
     * the same adapter id.
     *
     **/
    Ice.ObjectAdapterIdInUseException = function (_Ice$LocalException12) {
        _inherits(_class14, _Ice$LocalException12);

        function _class14() {
            var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class14);

            var _this14 = _possibleConstructorReturn(this, (_class14.__proto__ || Object.getPrototypeOf(_class14)).call(this, _cause));

            _this14.id = id;
            return _this14;
        }

        _createClass(_class14, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::ObjectAdapterIdInUseException";
            }
        }]);

        return _class14;
    }(Ice.LocalException);

    /**
     * This exception is raised if no suitable endpoint is available.
     *
     **/
    Ice.NoEndpointException = function (_Ice$LocalException13) {
        _inherits(_class15, _Ice$LocalException13);

        function _class15() {
            var proxy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class15);

            var _this15 = _possibleConstructorReturn(this, (_class15.__proto__ || Object.getPrototypeOf(_class15)).call(this, _cause));

            _this15.proxy = proxy;
            return _this15;
        }

        _createClass(_class15, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::NoEndpointException";
            }
        }]);

        return _class15;
    }(Ice.LocalException);

    /**
     * This exception is raised if there was an error while parsing an
     * endpoint.
     *
     **/
    Ice.EndpointParseException = function (_Ice$LocalException14) {
        _inherits(_class16, _Ice$LocalException14);

        function _class16() {
            var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class16);

            var _this16 = _possibleConstructorReturn(this, (_class16.__proto__ || Object.getPrototypeOf(_class16)).call(this, _cause));

            _this16.str = str;
            return _this16;
        }

        _createClass(_class16, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::EndpointParseException";
            }
        }]);

        return _class16;
    }(Ice.LocalException);

    /**
     * This exception is raised if there was an error while parsing an
     * endpoint selection type.
     *
     **/
    Ice.EndpointSelectionTypeParseException = function (_Ice$LocalException15) {
        _inherits(_class17, _Ice$LocalException15);

        function _class17() {
            var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class17);

            var _this17 = _possibleConstructorReturn(this, (_class17.__proto__ || Object.getPrototypeOf(_class17)).call(this, _cause));

            _this17.str = str;
            return _this17;
        }

        _createClass(_class17, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::EndpointSelectionTypeParseException";
            }
        }]);

        return _class17;
    }(Ice.LocalException);

    /**
     * This exception is raised if there was an error while parsing a
     * version.
     *
     **/
    Ice.VersionParseException = function (_Ice$LocalException16) {
        _inherits(_class18, _Ice$LocalException16);

        function _class18() {
            var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class18);

            var _this18 = _possibleConstructorReturn(this, (_class18.__proto__ || Object.getPrototypeOf(_class18)).call(this, _cause));

            _this18.str = str;
            return _this18;
        }

        _createClass(_class18, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::VersionParseException";
            }
        }]);

        return _class18;
    }(Ice.LocalException);

    /**
     * This exception is raised if there was an error while parsing a
     * stringified identity.
     *
     **/
    Ice.IdentityParseException = function (_Ice$LocalException17) {
        _inherits(_class19, _Ice$LocalException17);

        function _class19() {
            var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class19);

            var _this19 = _possibleConstructorReturn(this, (_class19.__proto__ || Object.getPrototypeOf(_class19)).call(this, _cause));

            _this19.str = str;
            return _this19;
        }

        _createClass(_class19, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::IdentityParseException";
            }
        }]);

        return _class19;
    }(Ice.LocalException);

    /**
     * This exception is raised if there was an error while parsing a
     * stringified proxy.
     *
     **/
    Ice.ProxyParseException = function (_Ice$LocalException18) {
        _inherits(_class20, _Ice$LocalException18);

        function _class20() {
            var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class20);

            var _this20 = _possibleConstructorReturn(this, (_class20.__proto__ || Object.getPrototypeOf(_class20)).call(this, _cause));

            _this20.str = str;
            return _this20;
        }

        _createClass(_class20, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::ProxyParseException";
            }
        }]);

        return _class20;
    }(Ice.LocalException);

    /**
     * This exception is raised if an illegal identity is encountered.
     *
     **/
    Ice.IllegalIdentityException = function (_Ice$LocalException19) {
        _inherits(_class21, _Ice$LocalException19);

        function _class21() {
            var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ice.Identity();

            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class21);

            var _this21 = _possibleConstructorReturn(this, (_class21.__proto__ || Object.getPrototypeOf(_class21)).call(this, _cause));

            _this21.id = id;
            return _this21;
        }

        _createClass(_class21, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::IllegalIdentityException";
            }
        }]);

        return _class21;
    }(Ice.LocalException);

    /**
     * This exception is raised to reject an illegal servant (typically
     * a null servant)
     *
     **/
    Ice.IllegalServantException = function (_Ice$LocalException20) {
        _inherits(_class22, _Ice$LocalException20);

        function _class22() {
            var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class22);

            var _this22 = _possibleConstructorReturn(this, (_class22.__proto__ || Object.getPrototypeOf(_class22)).call(this, _cause));

            _this22.reason = reason;
            return _this22;
        }

        _createClass(_class22, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::IllegalServantException";
            }
        }]);

        return _class22;
    }(Ice.LocalException);

    /**
     * This exception is raised if a request failed. This exception, and
     * all exceptions derived from {@link RequestFailedException}, are
     * transmitted by the Ice protocol, even though they are declared
     * <tt>local</tt>.
     *
     **/
    Ice.RequestFailedException = function (_Ice$LocalException21) {
        _inherits(_class23, _Ice$LocalException21);

        function _class23() {
            var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Ice.Identity();
            var facet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
            var operation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

            var _cause = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";

            _classCallCheck(this, _class23);

            var _this23 = _possibleConstructorReturn(this, (_class23.__proto__ || Object.getPrototypeOf(_class23)).call(this, _cause));

            _this23.id = id;
            _this23.facet = facet;
            _this23.operation = operation;
            return _this23;
        }

        _createClass(_class23, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::RequestFailedException";
            }
        }]);

        return _class23;
    }(Ice.LocalException);

    /**
     * This exception is raised if an object does not exist on the server,
     * that is, if no facets with the given identity exist.
     *
     **/
    Ice.ObjectNotExistException = function (_Ice$RequestFailedExc) {
        _inherits(_class24, _Ice$RequestFailedExc);

        function _class24(id, facet, operation) {
            var _cause = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";

            _classCallCheck(this, _class24);

            return _possibleConstructorReturn(this, (_class24.__proto__ || Object.getPrototypeOf(_class24)).call(this, id, facet, operation, _cause));
        }

        _createClass(_class24, null, [{
            key: "_parent",
            get: function get() {
                return Ice.RequestFailedException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::ObjectNotExistException";
            }
        }]);

        return _class24;
    }(Ice.RequestFailedException);

    /**
     * This exception is raised if no facet with the given name exists,
     * but at least one facet with the given identity exists.
     *
     **/
    Ice.FacetNotExistException = function (_Ice$RequestFailedExc2) {
        _inherits(_class25, _Ice$RequestFailedExc2);

        function _class25(id, facet, operation) {
            var _cause = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";

            _classCallCheck(this, _class25);

            return _possibleConstructorReturn(this, (_class25.__proto__ || Object.getPrototypeOf(_class25)).call(this, id, facet, operation, _cause));
        }

        _createClass(_class25, null, [{
            key: "_parent",
            get: function get() {
                return Ice.RequestFailedException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::FacetNotExistException";
            }
        }]);

        return _class25;
    }(Ice.RequestFailedException);

    /**
     * This exception is raised if an operation for a given object does
     * not exist on the server. Typically this is caused by either the
     * client or the server using an outdated Slice specification.
     *
     **/
    Ice.OperationNotExistException = function (_Ice$RequestFailedExc3) {
        _inherits(_class26, _Ice$RequestFailedExc3);

        function _class26(id, facet, operation) {
            var _cause = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";

            _classCallCheck(this, _class26);

            return _possibleConstructorReturn(this, (_class26.__proto__ || Object.getPrototypeOf(_class26)).call(this, id, facet, operation, _cause));
        }

        _createClass(_class26, null, [{
            key: "_parent",
            get: function get() {
                return Ice.RequestFailedException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::OperationNotExistException";
            }
        }]);

        return _class26;
    }(Ice.RequestFailedException);

    /**
     * This exception is raised if a system error occurred in the server
     * or client process. There are many possible causes for such a system
     * exception. For details on the cause, {@link SyscallException#error}
     * should be inspected.
     *
     **/
    Ice.SyscallException = function (_Ice$LocalException22) {
        _inherits(_class27, _Ice$LocalException22);

        function _class27() {
            var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class27);

            var _this27 = _possibleConstructorReturn(this, (_class27.__proto__ || Object.getPrototypeOf(_class27)).call(this, _cause));

            _this27.error = error;
            return _this27;
        }

        _createClass(_class27, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::SyscallException";
            }
        }]);

        return _class27;
    }(Ice.LocalException);

    /**
     * This exception indicates socket errors.
     *
     **/
    Ice.SocketException = function (_Ice$SyscallException) {
        _inherits(_class28, _Ice$SyscallException);

        function _class28(error) {
            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class28);

            return _possibleConstructorReturn(this, (_class28.__proto__ || Object.getPrototypeOf(_class28)).call(this, error, _cause));
        }

        _createClass(_class28, null, [{
            key: "_parent",
            get: function get() {
                return Ice.SyscallException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::SocketException";
            }
        }]);

        return _class28;
    }(Ice.SyscallException);

    /**
     * This exception indicates CFNetwork errors.
     *
     **/
    Ice.CFNetworkException = function (_Ice$SocketException) {
        _inherits(_class29, _Ice$SocketException);

        function _class29(error) {
            var domain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            var _cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

            _classCallCheck(this, _class29);

            var _this29 = _possibleConstructorReturn(this, (_class29.__proto__ || Object.getPrototypeOf(_class29)).call(this, error, _cause));

            _this29.domain = domain;
            return _this29;
        }

        _createClass(_class29, null, [{
            key: "_parent",
            get: function get() {
                return Ice.SocketException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::CFNetworkException";
            }
        }]);

        return _class29;
    }(Ice.SocketException);

    /**
     * This exception indicates file errors.
     *
     **/
    Ice.FileException = function (_Ice$SyscallException2) {
        _inherits(_class30, _Ice$SyscallException2);

        function _class30(error) {
            var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            var _cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

            _classCallCheck(this, _class30);

            var _this30 = _possibleConstructorReturn(this, (_class30.__proto__ || Object.getPrototypeOf(_class30)).call(this, error, _cause));

            _this30.path = path;
            return _this30;
        }

        _createClass(_class30, null, [{
            key: "_parent",
            get: function get() {
                return Ice.SyscallException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::FileException";
            }
        }]);

        return _class30;
    }(Ice.SyscallException);

    /**
     * This exception indicates connection failures.
     *
     **/
    Ice.ConnectFailedException = function (_Ice$SocketException2) {
        _inherits(_class31, _Ice$SocketException2);

        function _class31(error) {
            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class31);

            return _possibleConstructorReturn(this, (_class31.__proto__ || Object.getPrototypeOf(_class31)).call(this, error, _cause));
        }

        _createClass(_class31, null, [{
            key: "_parent",
            get: function get() {
                return Ice.SocketException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::ConnectFailedException";
            }
        }]);

        return _class31;
    }(Ice.SocketException);

    /**
     * This exception indicates a connection failure for which
     * the server host actively refuses a connection.
     *
     **/
    Ice.ConnectionRefusedException = function (_Ice$ConnectFailedExc) {
        _inherits(_class32, _Ice$ConnectFailedExc);

        function _class32(error) {
            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class32);

            return _possibleConstructorReturn(this, (_class32.__proto__ || Object.getPrototypeOf(_class32)).call(this, error, _cause));
        }

        _createClass(_class32, null, [{
            key: "_parent",
            get: function get() {
                return Ice.ConnectFailedException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::ConnectionRefusedException";
            }
        }]);

        return _class32;
    }(Ice.ConnectFailedException);

    /**
     * This exception indicates a lost connection.
     *
     **/
    Ice.ConnectionLostException = function (_Ice$SocketException3) {
        _inherits(_class33, _Ice$SocketException3);

        function _class33(error) {
            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class33);

            return _possibleConstructorReturn(this, (_class33.__proto__ || Object.getPrototypeOf(_class33)).call(this, error, _cause));
        }

        _createClass(_class33, null, [{
            key: "_parent",
            get: function get() {
                return Ice.SocketException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::ConnectionLostException";
            }
        }]);

        return _class33;
    }(Ice.SocketException);

    /**
     * This exception indicates a DNS problem. For details on the cause,
     * {@link DNSException#error} should be inspected.
     *
     **/
    Ice.DNSException = function (_Ice$LocalException23) {
        _inherits(_class34, _Ice$LocalException23);

        function _class34() {
            var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var host = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            var _cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

            _classCallCheck(this, _class34);

            var _this34 = _possibleConstructorReturn(this, (_class34.__proto__ || Object.getPrototypeOf(_class34)).call(this, _cause));

            _this34.error = error;
            _this34.host = host;
            return _this34;
        }

        _createClass(_class34, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::DNSException";
            }
        }]);

        return _class34;
    }(Ice.LocalException);

    /**
     * This exception indicates a request was interrupted.
     *
     **/
    Ice.OperationInterruptedException = function (_Ice$LocalException24) {
        _inherits(_class35, _Ice$LocalException24);

        function _class35() {
            var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            _classCallCheck(this, _class35);

            return _possibleConstructorReturn(this, (_class35.__proto__ || Object.getPrototypeOf(_class35)).call(this, _cause));
        }

        _createClass(_class35, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::OperationInterruptedException";
            }
        }]);

        return _class35;
    }(Ice.LocalException);

    /**
     * This exception indicates a timeout condition.
     *
     **/
    Ice.TimeoutException = function (_Ice$LocalException25) {
        _inherits(_class36, _Ice$LocalException25);

        function _class36() {
            var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            _classCallCheck(this, _class36);

            return _possibleConstructorReturn(this, (_class36.__proto__ || Object.getPrototypeOf(_class36)).call(this, _cause));
        }

        _createClass(_class36, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::TimeoutException";
            }
        }]);

        return _class36;
    }(Ice.LocalException);

    /**
     * This exception indicates a connection establishment timeout condition.
     *
     **/
    Ice.ConnectTimeoutException = function (_Ice$TimeoutException) {
        _inherits(_class37, _Ice$TimeoutException);

        function _class37() {
            var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            _classCallCheck(this, _class37);

            return _possibleConstructorReturn(this, (_class37.__proto__ || Object.getPrototypeOf(_class37)).call(this, _cause));
        }

        _createClass(_class37, null, [{
            key: "_parent",
            get: function get() {
                return Ice.TimeoutException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::ConnectTimeoutException";
            }
        }]);

        return _class37;
    }(Ice.TimeoutException);

    /**
     * This exception indicates a connection closure timeout condition.
     *
     **/
    Ice.CloseTimeoutException = function (_Ice$TimeoutException2) {
        _inherits(_class38, _Ice$TimeoutException2);

        function _class38() {
            var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            _classCallCheck(this, _class38);

            return _possibleConstructorReturn(this, (_class38.__proto__ || Object.getPrototypeOf(_class38)).call(this, _cause));
        }

        _createClass(_class38, null, [{
            key: "_parent",
            get: function get() {
                return Ice.TimeoutException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::CloseTimeoutException";
            }
        }]);

        return _class38;
    }(Ice.TimeoutException);

    /**
     * This exception indicates that a connection has been shut down because it has been
     * idle for some time.
     *
     **/
    Ice.ConnectionTimeoutException = function (_Ice$TimeoutException3) {
        _inherits(_class39, _Ice$TimeoutException3);

        function _class39() {
            var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            _classCallCheck(this, _class39);

            return _possibleConstructorReturn(this, (_class39.__proto__ || Object.getPrototypeOf(_class39)).call(this, _cause));
        }

        _createClass(_class39, null, [{
            key: "_parent",
            get: function get() {
                return Ice.TimeoutException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::ConnectionTimeoutException";
            }
        }]);

        return _class39;
    }(Ice.TimeoutException);

    /**
     * This exception indicates that an invocation failed because it timed
     * out.
     *
     **/
    Ice.InvocationTimeoutException = function (_Ice$TimeoutException4) {
        _inherits(_class40, _Ice$TimeoutException4);

        function _class40() {
            var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            _classCallCheck(this, _class40);

            return _possibleConstructorReturn(this, (_class40.__proto__ || Object.getPrototypeOf(_class40)).call(this, _cause));
        }

        _createClass(_class40, null, [{
            key: "_parent",
            get: function get() {
                return Ice.TimeoutException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::InvocationTimeoutException";
            }
        }]);

        return _class40;
    }(Ice.TimeoutException);

    /**
     * This exception indicates that an asynchronous invocation failed
     * because it was canceled explicitly by the user.
     *
     **/
    Ice.InvocationCanceledException = function (_Ice$LocalException26) {
        _inherits(_class41, _Ice$LocalException26);

        function _class41() {
            var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            _classCallCheck(this, _class41);

            return _possibleConstructorReturn(this, (_class41.__proto__ || Object.getPrototypeOf(_class41)).call(this, _cause));
        }

        _createClass(_class41, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::InvocationCanceledException";
            }
        }]);

        return _class41;
    }(Ice.LocalException);

    /**
     * A generic exception base for all kinds of protocol error
     * conditions.
     *
     **/
    Ice.ProtocolException = function (_Ice$LocalException27) {
        _inherits(_class42, _Ice$LocalException27);

        function _class42() {
            var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class42);

            var _this42 = _possibleConstructorReturn(this, (_class42.__proto__ || Object.getPrototypeOf(_class42)).call(this, _cause));

            _this42.reason = reason;
            return _this42;
        }

        _createClass(_class42, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::ProtocolException";
            }
        }]);

        return _class42;
    }(Ice.LocalException);

    /**
     * This exception indicates that a message did not start with the expected
     * magic number ('I', 'c', 'e', 'P').
     *
     **/
    Ice.BadMagicException = function (_Ice$ProtocolExceptio) {
        _inherits(_class43, _Ice$ProtocolExceptio);

        function _class43(reason) {
            var badMagic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            var _cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

            _classCallCheck(this, _class43);

            var _this43 = _possibleConstructorReturn(this, (_class43.__proto__ || Object.getPrototypeOf(_class43)).call(this, reason, _cause));

            _this43.badMagic = badMagic;
            return _this43;
        }

        _createClass(_class43, null, [{
            key: "_parent",
            get: function get() {
                return Ice.ProtocolException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::BadMagicException";
            }
        }]);

        return _class43;
    }(Ice.ProtocolException);

    /**
     * This exception indicates an unsupported protocol version.
     *
     **/
    Ice.UnsupportedProtocolException = function (_Ice$ProtocolExceptio2) {
        _inherits(_class44, _Ice$ProtocolExceptio2);

        function _class44(reason) {
            var bad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Ice.ProtocolVersion();
            var supported = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Ice.ProtocolVersion();

            var _cause = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";

            _classCallCheck(this, _class44);

            var _this44 = _possibleConstructorReturn(this, (_class44.__proto__ || Object.getPrototypeOf(_class44)).call(this, reason, _cause));

            _this44.bad = bad;
            _this44.supported = supported;
            return _this44;
        }

        _createClass(_class44, null, [{
            key: "_parent",
            get: function get() {
                return Ice.ProtocolException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::UnsupportedProtocolException";
            }
        }]);

        return _class44;
    }(Ice.ProtocolException);

    /**
     * This exception indicates an unsupported data encoding version.
     *
     **/
    Ice.UnsupportedEncodingException = function (_Ice$ProtocolExceptio3) {
        _inherits(_class45, _Ice$ProtocolExceptio3);

        function _class45(reason) {
            var bad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Ice.EncodingVersion();
            var supported = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Ice.EncodingVersion();

            var _cause = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";

            _classCallCheck(this, _class45);

            var _this45 = _possibleConstructorReturn(this, (_class45.__proto__ || Object.getPrototypeOf(_class45)).call(this, reason, _cause));

            _this45.bad = bad;
            _this45.supported = supported;
            return _this45;
        }

        _createClass(_class45, null, [{
            key: "_parent",
            get: function get() {
                return Ice.ProtocolException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::UnsupportedEncodingException";
            }
        }]);

        return _class45;
    }(Ice.ProtocolException);

    /**
     * This exception indicates that an unknown protocol message has been received.
     *
     **/
    Ice.UnknownMessageException = function (_Ice$ProtocolExceptio4) {
        _inherits(_class46, _Ice$ProtocolExceptio4);

        function _class46(reason) {
            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class46);

            return _possibleConstructorReturn(this, (_class46.__proto__ || Object.getPrototypeOf(_class46)).call(this, reason, _cause));
        }

        _createClass(_class46, null, [{
            key: "_parent",
            get: function get() {
                return Ice.ProtocolException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::UnknownMessageException";
            }
        }]);

        return _class46;
    }(Ice.ProtocolException);

    /**
     * This exception is raised if a message is received over a connection
     * that is not yet validated.
     *
     **/
    Ice.ConnectionNotValidatedException = function (_Ice$ProtocolExceptio5) {
        _inherits(_class47, _Ice$ProtocolExceptio5);

        function _class47(reason) {
            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class47);

            return _possibleConstructorReturn(this, (_class47.__proto__ || Object.getPrototypeOf(_class47)).call(this, reason, _cause));
        }

        _createClass(_class47, null, [{
            key: "_parent",
            get: function get() {
                return Ice.ProtocolException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::ConnectionNotValidatedException";
            }
        }]);

        return _class47;
    }(Ice.ProtocolException);

    /**
     * This exception indicates that a response for an unknown request ID has been
     * received.
     *
     **/
    Ice.UnknownRequestIdException = function (_Ice$ProtocolExceptio6) {
        _inherits(_class48, _Ice$ProtocolExceptio6);

        function _class48(reason) {
            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class48);

            return _possibleConstructorReturn(this, (_class48.__proto__ || Object.getPrototypeOf(_class48)).call(this, reason, _cause));
        }

        _createClass(_class48, null, [{
            key: "_parent",
            get: function get() {
                return Ice.ProtocolException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::UnknownRequestIdException";
            }
        }]);

        return _class48;
    }(Ice.ProtocolException);

    /**
     * This exception indicates that an unknown reply status has been received.
     *
     **/
    Ice.UnknownReplyStatusException = function (_Ice$ProtocolExceptio7) {
        _inherits(_class49, _Ice$ProtocolExceptio7);

        function _class49(reason) {
            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class49);

            return _possibleConstructorReturn(this, (_class49.__proto__ || Object.getPrototypeOf(_class49)).call(this, reason, _cause));
        }

        _createClass(_class49, null, [{
            key: "_parent",
            get: function get() {
                return Ice.ProtocolException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::UnknownReplyStatusException";
            }
        }]);

        return _class49;
    }(Ice.ProtocolException);

    /**
     * This exception indicates that the connection has been gracefully shut down by the
     * server. The operation call that caused this exception has not been
     * executed by the server. In most cases you will not get this
     * exception, because the client will automatically retry the
     * operation call in case the server shut down the connection. However,
     * if upon retry the server shuts down the connection again, and the
     * retry limit has been reached, then this exception is propagated to
     * the application code.
     *
     **/
    Ice.CloseConnectionException = function (_Ice$ProtocolExceptio8) {
        _inherits(_class50, _Ice$ProtocolExceptio8);

        function _class50(reason) {
            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class50);

            return _possibleConstructorReturn(this, (_class50.__proto__ || Object.getPrototypeOf(_class50)).call(this, reason, _cause));
        }

        _createClass(_class50, null, [{
            key: "_parent",
            get: function get() {
                return Ice.ProtocolException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::CloseConnectionException";
            }
        }]);

        return _class50;
    }(Ice.ProtocolException);

    /**
     * This exception is raised by an operation call if the application
     * closes the connection locally using {@link Connection#close}.
     *
     * @see Connection#close
     *
     **/
    Ice.ConnectionManuallyClosedException = function (_Ice$LocalException28) {
        _inherits(_class51, _Ice$LocalException28);

        function _class51() {
            var graceful = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class51);

            var _this51 = _possibleConstructorReturn(this, (_class51.__proto__ || Object.getPrototypeOf(_class51)).call(this, _cause));

            _this51.graceful = graceful;
            return _this51;
        }

        _createClass(_class51, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::ConnectionManuallyClosedException";
            }
        }]);

        return _class51;
    }(Ice.LocalException);

    /**
     * This exception indicates that a message size is less
     * than the minimum required size.
     *
     **/
    Ice.IllegalMessageSizeException = function (_Ice$ProtocolExceptio9) {
        _inherits(_class52, _Ice$ProtocolExceptio9);

        function _class52(reason) {
            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class52);

            return _possibleConstructorReturn(this, (_class52.__proto__ || Object.getPrototypeOf(_class52)).call(this, reason, _cause));
        }

        _createClass(_class52, null, [{
            key: "_parent",
            get: function get() {
                return Ice.ProtocolException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::IllegalMessageSizeException";
            }
        }]);

        return _class52;
    }(Ice.ProtocolException);

    /**
     * This exception indicates a problem with compressing or uncompressing data.
     *
     **/
    Ice.CompressionException = function (_Ice$ProtocolExceptio10) {
        _inherits(_class53, _Ice$ProtocolExceptio10);

        function _class53(reason) {
            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class53);

            return _possibleConstructorReturn(this, (_class53.__proto__ || Object.getPrototypeOf(_class53)).call(this, reason, _cause));
        }

        _createClass(_class53, null, [{
            key: "_parent",
            get: function get() {
                return Ice.ProtocolException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::CompressionException";
            }
        }]);

        return _class53;
    }(Ice.ProtocolException);

    /**
     * A datagram exceeds the configured size.
     *
     * This exception is raised if a datagram exceeds the configured send or receive buffer
     * size, or exceeds the maximum payload size of a UDP packet (65507 bytes).
     *
     **/
    Ice.DatagramLimitException = function (_Ice$ProtocolExceptio11) {
        _inherits(_class54, _Ice$ProtocolExceptio11);

        function _class54(reason) {
            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class54);

            return _possibleConstructorReturn(this, (_class54.__proto__ || Object.getPrototypeOf(_class54)).call(this, reason, _cause));
        }

        _createClass(_class54, null, [{
            key: "_parent",
            get: function get() {
                return Ice.ProtocolException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::DatagramLimitException";
            }
        }]);

        return _class54;
    }(Ice.ProtocolException);

    /**
     * This exception is raised for errors during marshaling or unmarshaling data.
     *
     **/
    Ice.MarshalException = function (_Ice$ProtocolExceptio12) {
        _inherits(_class55, _Ice$ProtocolExceptio12);

        function _class55(reason) {
            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class55);

            return _possibleConstructorReturn(this, (_class55.__proto__ || Object.getPrototypeOf(_class55)).call(this, reason, _cause));
        }

        _createClass(_class55, null, [{
            key: "_parent",
            get: function get() {
                return Ice.ProtocolException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::MarshalException";
            }
        }]);

        return _class55;
    }(Ice.ProtocolException);

    /**
     * This exception is raised if inconsistent data is received while unmarshaling a proxy.
     *
     **/
    Ice.ProxyUnmarshalException = function (_Ice$MarshalException) {
        _inherits(_class56, _Ice$MarshalException);

        function _class56(reason) {
            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class56);

            return _possibleConstructorReturn(this, (_class56.__proto__ || Object.getPrototypeOf(_class56)).call(this, reason, _cause));
        }

        _createClass(_class56, null, [{
            key: "_parent",
            get: function get() {
                return Ice.MarshalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::ProxyUnmarshalException";
            }
        }]);

        return _class56;
    }(Ice.MarshalException);

    /**
     * This exception is raised if an out-of-bounds condition occurs during unmarshaling.
     *
     **/
    Ice.UnmarshalOutOfBoundsException = function (_Ice$MarshalException2) {
        _inherits(_class57, _Ice$MarshalException2);

        function _class57(reason) {
            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class57);

            return _possibleConstructorReturn(this, (_class57.__proto__ || Object.getPrototypeOf(_class57)).call(this, reason, _cause));
        }

        _createClass(_class57, null, [{
            key: "_parent",
            get: function get() {
                return Ice.MarshalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::UnmarshalOutOfBoundsException";
            }
        }]);

        return _class57;
    }(Ice.MarshalException);

    /**
     * This exception is raised if no suitable value factory was found during
     * unmarshaling of a Slice class instance.
     *
     * @see ValueFactory
     * @see Communicator#getValueFactoryManager
     * @see ValueFactoryManager#add
     * @see ValueFactoryManager#find
     *
     **/
    Ice.NoValueFactoryException = function (_Ice$MarshalException3) {
        _inherits(_class58, _Ice$MarshalException3);

        function _class58(reason) {
            var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            var _cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

            _classCallCheck(this, _class58);

            var _this58 = _possibleConstructorReturn(this, (_class58.__proto__ || Object.getPrototypeOf(_class58)).call(this, reason, _cause));

            _this58.type = type;
            return _this58;
        }

        _createClass(_class58, null, [{
            key: "_parent",
            get: function get() {
                return Ice.MarshalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::NoValueFactoryException";
            }
        }]);

        return _class58;
    }(Ice.MarshalException);

    /**
     * This exception is raised if the type of an unmarshaled Slice class instance does
     * not match its expected type.
     * This can happen if client and server are compiled with mismatched Slice
     * definitions or if a class of the wrong type is passed as a parameter
     * or return value using dynamic invocation. This exception can also be
     * raised if IceStorm is used to send Slice class instances and
     * an operation is subscribed to the wrong topic.
     *
     **/
    Ice.UnexpectedObjectException = function (_Ice$MarshalException4) {
        _inherits(_class59, _Ice$MarshalException4);

        function _class59(reason) {
            var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
            var expectedType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

            var _cause = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";

            _classCallCheck(this, _class59);

            var _this59 = _possibleConstructorReturn(this, (_class59.__proto__ || Object.getPrototypeOf(_class59)).call(this, reason, _cause));

            _this59.type = type;
            _this59.expectedType = expectedType;
            return _this59;
        }

        _createClass(_class59, null, [{
            key: "_parent",
            get: function get() {
                return Ice.MarshalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::UnexpectedObjectException";
            }
        }]);

        return _class59;
    }(Ice.MarshalException);

    /**
     * This exception is raised when Ice receives a request or reply
     * message whose size exceeds the limit specified by the
     * <tt>Ice.MessageSizeMax</tt> property.
     *
     **/
    Ice.MemoryLimitException = function (_Ice$MarshalException5) {
        _inherits(_class60, _Ice$MarshalException5);

        function _class60(reason) {
            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class60);

            return _possibleConstructorReturn(this, (_class60.__proto__ || Object.getPrototypeOf(_class60)).call(this, reason, _cause));
        }

        _createClass(_class60, null, [{
            key: "_parent",
            get: function get() {
                return Ice.MarshalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::MemoryLimitException";
            }
        }]);

        return _class60;
    }(Ice.MarshalException);

    /**
     * This exception is raised when a string conversion to or from UTF-8
     * fails during marshaling or unmarshaling.
     *
     **/
    Ice.StringConversionException = function (_Ice$MarshalException6) {
        _inherits(_class61, _Ice$MarshalException6);

        function _class61(reason) {
            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class61);

            return _possibleConstructorReturn(this, (_class61.__proto__ || Object.getPrototypeOf(_class61)).call(this, reason, _cause));
        }

        _createClass(_class61, null, [{
            key: "_parent",
            get: function get() {
                return Ice.MarshalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::StringConversionException";
            }
        }]);

        return _class61;
    }(Ice.MarshalException);

    /**
     * This exception indicates a malformed data encapsulation.
     *
     **/
    Ice.EncapsulationException = function (_Ice$MarshalException7) {
        _inherits(_class62, _Ice$MarshalException7);

        function _class62(reason) {
            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class62);

            return _possibleConstructorReturn(this, (_class62.__proto__ || Object.getPrototypeOf(_class62)).call(this, reason, _cause));
        }

        _createClass(_class62, null, [{
            key: "_parent",
            get: function get() {
                return Ice.MarshalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::EncapsulationException";
            }
        }]);

        return _class62;
    }(Ice.MarshalException);

    /**
     * This exception is raised if an unsupported feature is used. The
     * unsupported feature string contains the name of the unsupported
     * feature
     *
     **/
    Ice.FeatureNotSupportedException = function (_Ice$LocalException29) {
        _inherits(_class63, _Ice$LocalException29);

        function _class63() {
            var unsupportedFeature = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class63);

            var _this63 = _possibleConstructorReturn(this, (_class63.__proto__ || Object.getPrototypeOf(_class63)).call(this, _cause));

            _this63.unsupportedFeature = unsupportedFeature;
            return _this63;
        }

        _createClass(_class63, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::FeatureNotSupportedException";
            }
        }]);

        return _class63;
    }(Ice.LocalException);

    /**
     * This exception indicates a failure in a security subsystem,
     * such as the IceSSL plug-in.
     *
     **/
    Ice.SecurityException = function (_Ice$LocalException30) {
        _inherits(_class64, _Ice$LocalException30);

        function _class64() {
            var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            var _cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

            _classCallCheck(this, _class64);

            var _this64 = _possibleConstructorReturn(this, (_class64.__proto__ || Object.getPrototypeOf(_class64)).call(this, _cause));

            _this64.reason = reason;
            return _this64;
        }

        _createClass(_class64, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::SecurityException";
            }
        }]);

        return _class64;
    }(Ice.LocalException);

    /**
     * This exception indicates that an attempt has been made to
     * change the connection properties of a fixed proxy.
     *
     **/
    Ice.FixedProxyException = function (_Ice$LocalException31) {
        _inherits(_class65, _Ice$LocalException31);

        function _class65() {
            var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            _classCallCheck(this, _class65);

            return _possibleConstructorReturn(this, (_class65.__proto__ || Object.getPrototypeOf(_class65)).call(this, _cause));
        }

        _createClass(_class65, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::FixedProxyException";
            }
        }]);

        return _class65;
    }(Ice.LocalException);

    /**
     * Indicates that the response to a request has already been sent;
     * re-dispatching such a request is not possible.
     *
     **/
    Ice.ResponseSentException = function (_Ice$LocalException32) {
        _inherits(_class66, _Ice$LocalException32);

        function _class66() {
            var _cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

            _classCallCheck(this, _class66);

            return _possibleConstructorReturn(this, (_class66.__proto__ || Object.getPrototypeOf(_class66)).call(this, _cause));
        }

        _createClass(_class66, null, [{
            key: "_parent",
            get: function get() {
                return Ice.LocalException;
            }
        }, {
            key: "_id",
            get: function get() {
                return "::Ice::ResponseSentException";
            }
        }]);

        return _class66;
    }(Ice.LocalException);
    /* slice2js browser-bundle-skip */
    exports.Ice = Ice;
    /* slice2js browser-bundle-skip-end */
    /* slice2js browser-bundle-skip */
})(typeof global !== "undefined" && typeof global.process !== "undefined" ? module : undefined, typeof global !== "undefined" && typeof global.process !== "undefined" ? require : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self.Ice._require : window.Ice._require, typeof global !== "undefined" && typeof global.process !== "undefined" ? exports : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : window);
/* slice2js browser-bundle-skip-end */